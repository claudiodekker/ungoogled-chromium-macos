name: Check for new releases

on:
  workflow_dispatch:
  schedule:
    - cron: '*/20 * * * *'

jobs:
  check:
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read

    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            async function getSignedReleases() {
              const releases = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
              });
            
              return releases.data
                .map(release => release.tag_name)
                .filter(tag => tag.includes('__'))
            }
            
            async function parseLatestReleases(apiReleasesResponseJson) {
              const actionsBasedReleases = apiReleasesResponseJson
                .filter(release => release.author.login === 'github-actions[bot]')
                .filter(release => release.author.type === 'Bot')
            
              const parsableReleases = actionsBasedReleases
                .filter(release => release.body.includes("sha256"))
                .filter(release => release.assets.some(asset => asset.browser_download_url.endsWith('.dmg')))
            
              const parsedReleases = parsableReleases.map(release => {
                const url = release.assets.find(asset => asset.browser_download_url.endsWith('.dmg')).browser_download_url
                const sha256 = release.body.split('sha256: ')[1].split('\n')[0]
                const filename = url.split('/').pop()
                const tag = url.split('/releases/download/')[1].split('/')[0]
            
                const matches = /^(?<chromium_version>.*)-(?<ungoogled_revision>.*)\.(?<package_revision>.*)_(?<cpu>.*)__(?<epoch_finish>\d{10,20})$/.exec(tag)
                if (matches == null) {
                  return null
                }
            
                return {
                  url,
                  filename,
                  sha256,
                  tag: {
                    full: tag,
                    ...matches.groups,
                  },
                }
              })
                .filter(Boolean)
                .filter(release => release.filename.endsWith("-macos.dmg"))
                .filter(release => release.sha256.length === 64)
            
              const groupedReleases = parsedReleases.reduce((group, release) => {
                if (!group[release.tag.cpu]) {
                  group[release.tag.cpu] = release
                }
            
                return group
              }, {})
            
              return Object.values(groupedReleases).map(release => ({
                tag: release.tag.full,
                url: release.url,
                sha256: release.sha256,
              }));
            }
            
            async function getUnsignedReleases() {
              const releases = await github.rest.repos.listReleases({
                owner: 'ungoogled-software',
                repo: 'ungoogled-chromium-macos'
              });
            
              return await parseLatestReleases(releases.data)
            }
            
            async function findSignableReleases() {
              const unsignedReleases = await getUnsignedReleases()
              const signedReleases = await getSignedReleases()
            
              return unsignedReleases
                .filter(release => !signedReleases.includes(release.tag))
                .reduce((group, release) => ({
                  ...group,
                  [release.sha256]: release.url,
                }), {})
            }
            
            for ([sha256, url] of Object.entries(await findSignableReleases())) {
              core.notice("Found new release: " + url)
            
              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: context.ref,
                workflow_id: 'sign.yml',
                inputs: {
                  asset: url.split("/releases/download/")[1],
                  sha256: sha256,
                },
              })
            }
